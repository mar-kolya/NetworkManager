From: Thomas Haller <thaller@redhat.com>
Date: Fri, 2 Jun 2017 21:04:12 +0200
Subject: device: merge various device cleanups

---
 src/devices/nm-device-bond.c      |  3 +-
 src/devices/nm-device-bridge.c    |  3 +-
 src/devices/nm-device-ethernet.c  | 56 +++++++++++++++++--------------
 src/devices/nm-device.c           | 70 ++++++++++++++++++---------------------
 src/devices/nm-device.h           |  6 +---
 src/devices/team/nm-device-team.c |  3 +-
 6 files changed, 69 insertions(+), 72 deletions(-)

diff --git a/src/devices/nm-device-bond.c b/src/devices/nm-device-bond.c
index 1829139..3325c94 100644
--- a/src/devices/nm-device-bond.c
+++ b/src/devices/nm-device-bond.c
@@ -613,7 +613,6 @@ reapply_connection (NMDevice *device, NMConnection *con_old, NMConnection *con_n
 static void
 nm_device_bond_init (NMDeviceBond * self)
 {
-	nm_assert (nm_device_is_master (NM_DEVICE (self)));
 }
 
 static void
@@ -623,7 +622,6 @@ nm_device_bond_class_init (NMDeviceBondClass *klass)
 
 	NM_DEVICE_CLASS_DECLARE_TYPES (klass, NM_SETTING_BOND_SETTING_NAME, NM_LINK_TYPE_BOND)
 
-	parent_class->is_master = TRUE;
 	parent_class->get_generic_capabilities = get_generic_capabilities;
 	parent_class->is_available = is_available;
 	parent_class->check_connection_compatible = check_connection_compatible;
@@ -664,6 +662,7 @@ create_device (NMDeviceFactory *factory,
 	                                  NM_DEVICE_TYPE_DESC, "Bond",
 	                                  NM_DEVICE_DEVICE_TYPE, NM_DEVICE_TYPE_BOND,
 	                                  NM_DEVICE_LINK_TYPE, NM_LINK_TYPE_BOND,
+	                                  NM_DEVICE_IS_MASTER, TRUE,
 	                                  NULL);
 }
 
diff --git a/src/devices/nm-device-bridge.c b/src/devices/nm-device-bridge.c
index 166e1bd..c281dba 100644
--- a/src/devices/nm-device-bridge.c
+++ b/src/devices/nm-device-bridge.c
@@ -494,7 +494,6 @@ create_and_realize (NMDevice *device,
 static void
 nm_device_bridge_init (NMDeviceBridge * self)
 {
-	nm_assert (nm_device_is_master (NM_DEVICE (self)));
 }
 
 static void
@@ -504,7 +503,6 @@ nm_device_bridge_class_init (NMDeviceBridgeClass *klass)
 
 	NM_DEVICE_CLASS_DECLARE_TYPES (klass, NM_SETTING_BRIDGE_SETTING_NAME, NM_LINK_TYPE_BRIDGE)
 
-	parent_class->is_master = TRUE;
 	parent_class->get_generic_capabilities = get_generic_capabilities;
 	parent_class->is_available = is_available;
 	parent_class->check_connection_compatible = check_connection_compatible;
@@ -545,6 +543,7 @@ create_device (NMDeviceFactory *factory,
 	                                  NM_DEVICE_TYPE_DESC, "Bridge",
 	                                  NM_DEVICE_DEVICE_TYPE, NM_DEVICE_TYPE_BRIDGE,
 	                                  NM_DEVICE_LINK_TYPE, NM_LINK_TYPE_BRIDGE,
+	                                  NM_DEVICE_IS_MASTER, TRUE,
 	                                  NULL);
 }
 
diff --git a/src/devices/nm-device-ethernet.c b/src/devices/nm-device-ethernet.c
index 8044ec3..8a04d40 100644
--- a/src/devices/nm-device-ethernet.c
+++ b/src/devices/nm-device-ethernet.c
@@ -115,8 +115,7 @@ typedef struct _NMDeviceEthernetPrivate {
 	/* DCB */
 	DcbWait       dcb_wait;
 	guint         dcb_timeout_id;
-
-	bool          dcb_handle_carrier_changes:1;
+	gulong        dcb_carrier_id;
 } NMDeviceEthernetPrivate;
 
 NM_GOBJECT_PROPERTIES_DEFINE (NMDeviceEthernet,
@@ -1134,7 +1133,7 @@ dcb_state (NMDevice *device, gboolean timeout)
 			_LOGD (LOGD_DCB, "dcb_state() enabling DCB");
 			nm_clear_g_source (&priv->dcb_timeout_id);
 			if (!dcb_enable (device)) {
-				priv->dcb_handle_carrier_changes = FALSE;
+				nm_clear_g_signal_handler (device, &priv->dcb_carrier_id);
 				nm_device_state_changed (device,
 				                         NM_DEVICE_STATE_FAILED,
 				                         NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED);
@@ -1158,7 +1157,7 @@ dcb_state (NMDevice *device, gboolean timeout)
 			_LOGD (LOGD_DCB, "dcb_state() preconfig up configuring DCB");
 			nm_clear_g_source (&priv->dcb_timeout_id);
 			if (!dcb_configure (device)) {
-				priv->dcb_handle_carrier_changes = FALSE;
+				nm_clear_g_signal_handler (device, &priv->dcb_carrier_id);
 				nm_device_state_changed (device,
 				                         NM_DEVICE_STATE_FAILED,
 				                         NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED);
@@ -1181,7 +1180,7 @@ dcb_state (NMDevice *device, gboolean timeout)
 		if (timeout || carrier) {
 			_LOGD (LOGD_DCB, "dcb_state() postconfig up starting IP");
 			nm_clear_g_source (&priv->dcb_timeout_id);
-			priv->dcb_handle_carrier_changes = FALSE;
+			nm_clear_g_signal_handler (device, &priv->dcb_carrier_id);
 			priv->dcb_wait = DCB_WAIT_UNKNOWN;
 			nm_device_activate_schedule_stage3_ip_config_start (device);
 		}
@@ -1191,6 +1190,20 @@ dcb_state (NMDevice *device, gboolean timeout)
 	}
 }
 
+static void
+dcb_carrier_changed (NMDevice *device, GParamSpec *pspec, gpointer unused)
+{
+	NMDeviceEthernet *self = NM_DEVICE_ETHERNET (device);
+	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
+
+	g_return_if_fail (nm_device_get_state (device) == NM_DEVICE_STATE_CONFIG);
+
+	if (priv->dcb_timeout_id) {
+		_LOGD (LOGD_DCB, "carrier_changed() calling dcb_state()");
+		dcb_state (device, FALSE);
+	}
+}
+
 /*****************************************************************************/
 
 static gboolean
@@ -1249,7 +1262,7 @@ act_stage2_config (NMDevice *device, NMDeviceStateReason *out_failure_reason)
 	g_return_val_if_fail (s_con, NM_ACT_STAGE_RETURN_FAILURE);
 
 	nm_clear_g_source (&priv->dcb_timeout_id);
-	priv->dcb_handle_carrier_changes = FALSE;
+	nm_clear_g_signal_handler (device, &priv->dcb_carrier_id);
 
 	/* 802.1x has to run before any IP configuration since the 802.1x auth
 	 * process opens the port up for normal traffic.
@@ -1283,7 +1296,13 @@ act_stage2_config (NMDevice *device, NMDeviceStateReason *out_failure_reason)
 			priv->dcb_timeout_id = g_timeout_add_seconds (4, dcb_carrier_timeout, device);
 		}
 
-		priv->dcb_handle_carrier_changes = TRUE;
+		/* Watch carrier independently of NMDeviceClass::carrier_changed so
+		 * we get instant notifications of disconnection that aren't deferred.
+		 */
+		priv->dcb_carrier_id = g_signal_connect (device,
+		                                         "notify::" NM_DEVICE_CARRIER,
+		                                         G_CALLBACK (dcb_carrier_changed),
+		                                         NULL);
 		ret = NM_ACT_STAGE_RETURN_POSTPONE;
 	}
 
@@ -1367,7 +1386,7 @@ deactivate (NMDevice *device)
 
 	priv->dcb_wait = DCB_WAIT_UNKNOWN;
 	nm_clear_g_source (&priv->dcb_timeout_id);
-	priv->dcb_handle_carrier_changes = FALSE;
+	nm_clear_g_signal_handler (device, &priv->dcb_carrier_id);
 
 	/* Tear down DCB/FCoE if it was enabled */
 	s_dcb = (NMSettingDcb *) nm_device_get_applied_setting (device, NM_TYPE_SETTING_DCB);
@@ -1560,7 +1579,7 @@ update_connection (NMDevice *device, NMConnection *connection)
 }
 
 static void
-link_speed_update (NMDevice *device)
+get_link_speed (NMDevice *device)
 {
 	NMDeviceEthernet *self = NM_DEVICE_ETHERNET (device);
 	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
@@ -1572,28 +1591,16 @@ link_speed_update (NMDevice *device)
 		return;
 
 	priv->speed = speed;
-	_LOGD (LOGD_PLATFORM | LOGD_ETHER, "speed is now %d Mb/s", speed);
 	_notify (self, PROP_SPEED);
+
+	_LOGD (LOGD_PLATFORM | LOGD_ETHER, "speed is now %d Mb/s", speed);
 }
 
 static void
 carrier_changed_notify (NMDevice *device, gboolean carrier)
 {
-	NMDeviceEthernet *self = NM_DEVICE_ETHERNET (device);
-	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
-
-	if (priv->dcb_handle_carrier_changes) {
-		nm_assert (nm_device_get_state (device) == NM_DEVICE_STATE_CONFIG);
-
-		if (priv->dcb_timeout_id) {
-			_LOGD (LOGD_DCB, "carrier_changed() calling dcb_state()");
-			dcb_state (device, FALSE);
-		}
-	}
-
 	if (carrier)
-		link_speed_update (device);
-
+		get_link_speed (device);
 	NM_DEVICE_CLASS (nm_device_ethernet_parent_class)->carrier_changed_notify (device, carrier);
 }
 
@@ -1675,6 +1682,7 @@ dispose (GObject *object)
 	nm_clear_g_source (&priv->pppoe_wait_id);
 
 	nm_clear_g_source (&priv->dcb_timeout_id);
+	nm_clear_g_signal_handler (self, &priv->dcb_carrier_id);
 
 	G_OBJECT_CLASS (nm_device_ethernet_parent_class)->dispose (object);
 }
diff --git a/src/devices/nm-device.c b/src/devices/nm-device.c
index de3bc68..e11b715 100644
--- a/src/devices/nm-device.c
+++ b/src/devices/nm-device.c
@@ -188,6 +188,7 @@ NM_GOBJECT_PROPERTIES_DEFINE (NMDevice,
 	PROP_IFINDEX,
 	PROP_AVAILABLE_CONNECTIONS,
 	PROP_PHYSICAL_PORT_ID,
+	PROP_IS_MASTER,
 	PROP_MASTER,
 	PROP_PARENT,
 	PROP_HW_ADDRESS,
@@ -450,6 +451,7 @@ typedef struct _NMDevicePrivate {
 	gulong          master_ready_id;
 
 	/* slave management */
+	bool            is_master;
 	CList           slaves;    /* list of SlaveInfo */
 
 	NMMetered       metered;
@@ -2181,6 +2183,8 @@ carrier_changed (NMDevice *self, gboolean carrier)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
+	NM_DEVICE_GET_CLASS (self)->carrier_changed_notify (self, carrier);
+
 	if (priv->state <= NM_DEVICE_STATE_UNMANAGED)
 		return;
 
@@ -2190,7 +2194,7 @@ carrier_changed (NMDevice *self, gboolean carrier)
 	if (priv->ignore_carrier && !carrier)
 		return;
 
-	if (nm_device_is_master (self)) {
+	if (priv->is_master) {
 		/* Bridge/bond/team carrier does not affect its own activation,
 		 * but when carrier comes on, if there are slaves waiting,
 		 * it will restart them.
@@ -2250,7 +2254,7 @@ carrier_disconnected_action_cb (gpointer user_data)
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
-	_LOGD (LOGD_DEVICE, "carrier: link disconnected (calling deferred action) (id=%u)", priv->carrier_defer_id);
+	_LOGD (LOGD_DEVICE, "link disconnected (calling deferred action) (id=%u)", priv->carrier_defer_id);
 
 	priv->carrier_defer_id = 0;
 	carrier_changed (self, FALSE);
@@ -2264,7 +2268,7 @@ carrier_disconnected_action_cancel (NMDevice *self)
 	guint id = priv->carrier_defer_id;
 
 	if (nm_clear_g_source (&priv->carrier_defer_id)) {
-		_LOGD (LOGD_DEVICE, "carrier: link disconnected (canceling deferred action) (id=%u)",
+		_LOGD (LOGD_DEVICE, "link disconnected (canceling deferred action) (id=%u)",
 		       id);
 	}
 }
@@ -2282,9 +2286,8 @@ nm_device_set_carrier (NMDevice *self, gboolean carrier)
 	_notify (self, PROP_CARRIER);
 
 	if (priv->carrier) {
-		_LOGI (LOGD_DEVICE, "carrier: link connected");
+		_LOGI (LOGD_DEVICE, "link connected");
 		carrier_disconnected_action_cancel (self);
-		NM_DEVICE_GET_CLASS (self)->carrier_changed_notify (self, carrier);
 		carrier_changed (self, TRUE);
 
 		if (priv->carrier_wait_id) {
@@ -2294,15 +2297,14 @@ nm_device_set_carrier (NMDevice *self, gboolean carrier)
 	} else {
 		if (priv->carrier_wait_id)
 			nm_device_add_pending_action (self, NM_PENDING_ACTION_CARRIER_WAIT, FALSE);
-		NM_DEVICE_GET_CLASS (self)->carrier_changed_notify (self, carrier);
 		if (   state <= NM_DEVICE_STATE_DISCONNECTED
 		    && !priv->queued_act_request) {
-			_LOGD (LOGD_DEVICE, "carrier: link disconnected");
+			_LOGD (LOGD_DEVICE, "link disconnected");
 			carrier_changed (self, FALSE);
 		} else {
 			priv->carrier_defer_id = g_timeout_add_seconds (LINK_DISCONNECT_DELAY,
 			                                                carrier_disconnected_action_cb, self);
-			_LOGD (LOGD_DEVICE, "carrier: link disconnected (deferring action for %d seconds) (id=%u)",
+			_LOGD (LOGD_DEVICE, "link disconnected (deferring action for %d seconds) (id=%u)",
 			       LINK_DISCONNECT_DELAY, priv->carrier_defer_id);
 		}
 	}
@@ -3529,9 +3531,7 @@ nm_device_master_release_slaves (NMDevice *self)
 gboolean
 nm_device_is_master (NMDevice *self)
 {
-	g_return_val_if_fail (NM_IS_DEVICE (self), FALSE);
-
-	return NM_DEVICE_GET_CLASS (self)->is_master;
+	return NM_DEVICE_GET_PRIVATE (self)->is_master;
 }
 
 /**
@@ -4190,7 +4190,7 @@ nm_device_check_slave_connection_compatible (NMDevice *self, NMConnection *slave
 
 	priv = NM_DEVICE_GET_PRIVATE (self);
 
-	if (!nm_device_is_master (self))
+	if (!priv->is_master)
 		return FALSE;
 
 	/* All masters should have connection type set */
@@ -6033,14 +6033,14 @@ act_stage3_ip4_config_start (NMDevice *self,
 	g_return_val_if_fail (connection, NM_ACT_STAGE_RETURN_FAILURE);
 
 	if (   connection_ip4_method_requires_carrier (connection, NULL)
-	    && nm_device_is_master (self)
+	    && priv->is_master
 	    && !priv->carrier) {
 		_LOGI (LOGD_IP4 | LOGD_DEVICE,
 		       "IPv4 config waiting until carrier is on");
 		return NM_ACT_STAGE_RETURN_IP_WAIT;
 	}
 
-	if (nm_device_is_master (self) && ip4_requires_slaves (connection)) {
+	if (priv->is_master && ip4_requires_slaves (connection)) {
 		/* If the master has no ready slaves, and depends on slaves for
 		 * a successful IPv4 attempt, then postpone IPv4 addressing.
 		 */
@@ -7634,14 +7634,14 @@ act_stage3_ip6_config_start (NMDevice *self,
 	g_return_val_if_fail (connection, NM_ACT_STAGE_RETURN_FAILURE);
 
 	if (   connection_ip6_method_requires_carrier (connection, NULL)
-	    && nm_device_is_master (self)
+	    && priv->is_master
 	    && !priv->carrier) {
 		_LOGI (LOGD_IP6 | LOGD_DEVICE,
 		       "IPv6 config waiting until carrier is on");
 		return NM_ACT_STAGE_RETURN_IP_WAIT;
 	}
 
-	if (nm_device_is_master (self) && ip6_requires_slaves (connection)) {
+	if (priv->is_master && ip6_requires_slaves (connection)) {
 		/* If the master has no ready slaves, and depends on slaves for
 		 * a successful IPv6 attempt, then postpone IPv6 addressing.
 		 */
@@ -8268,7 +8268,7 @@ arp_announce (NMDevice *self)
 }
 
 static void
-activate_stage5_ip4_config_result (NMDevice *self)
+activate_stage5_ip4_config_commit (NMDevice *self)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	NMActRequest *req;
@@ -8340,7 +8340,7 @@ nm_device_activate_schedule_ip4_config_result (NMDevice *self, NMIP4Config *conf
 	if (config)
 		priv->dev_ip4_config = g_object_ref (config);
 
-	activation_source_schedule (self, activate_stage5_ip4_config_result, AF_INET);
+	activation_source_schedule (self, activate_stage5_ip4_config_commit, AF_INET);
 }
 
 gboolean
@@ -10540,7 +10540,7 @@ update_ip4_config (NMDevice *self, gboolean initial)
 	 */
 	if (   !initial
 	    && activation_source_is_scheduled (self,
-	                                       activate_stage5_ip4_config_result,
+	                                       activate_stage5_ip4_config_commit,
 	                                       AF_INET)) {
 		priv->queued_ip4_config_pending = FALSE;
 		priv->queued_ip4_config_id = g_idle_add (queued_ip4_config_change, self);
@@ -13464,12 +13464,6 @@ nm_device_get_initial_hw_address (NMDevice *self)
 gboolean
 nm_device_spec_match_list (NMDevice *self, const GSList *specs)
 {
-	return nm_device_spec_match_list_full (self, specs, FALSE);
-}
-
-int
-nm_device_spec_match_list_full (NMDevice *self, const GSList *specs, int no_match_value)
-{
 	NMDeviceClass *klass;
 	NMMatchSpecMatchType m;
 
@@ -13484,17 +13478,7 @@ nm_device_spec_match_list_full (NMDevice *self, const GSList *specs, int no_matc
 	                          nm_device_get_driver_version (self),
 	                          nm_device_get_permanent_hw_address (self),
 	                          klass->get_s390_subchannels ? klass->get_s390_subchannels (self) : NULL);
-
-	switch (m) {
-	case NM_MATCH_SPEC_MATCH:
-		return TRUE;
-	case NM_MATCH_SPEC_NEG_MATCH:
-		return FALSE;
-	case NM_MATCH_SPEC_NO_MATCH:
-		return no_match_value;
-	}
-	nm_assert_not_reached ();
-	return no_match_value;
+	return m == NM_MATCH_SPEC_MATCH;
 }
 
 guint
@@ -13539,7 +13523,7 @@ _activation_func_to_string (ActivationHandleFunc func)
 	FUNC_TO_STRING_CHECK_AND_RETURN (func, activate_stage3_ip_config_start);
 	FUNC_TO_STRING_CHECK_AND_RETURN (func, activate_stage4_ip4_config_timeout);
 	FUNC_TO_STRING_CHECK_AND_RETURN (func, activate_stage4_ip6_config_timeout);
-	FUNC_TO_STRING_CHECK_AND_RETURN (func, activate_stage5_ip4_config_result);
+	FUNC_TO_STRING_CHECK_AND_RETURN (func, activate_stage5_ip4_config_commit);
 	FUNC_TO_STRING_CHECK_AND_RETURN (func, activate_stage5_ip6_config_commit);
 	g_return_val_if_reached ("unknown");
 }
@@ -13880,6 +13864,10 @@ set_property (GObject *object, guint prop_id,
 		/* construct-only */
 		priv->rfkill_type = g_value_get_uint (value);
 		break;
+	case PROP_IS_MASTER:
+		/* construct-only */
+		priv->is_master = g_value_get_boolean (value);
+		break;
 	case PROP_PERM_HW_ADDRESS:
 		/* construct-only */
 		priv->hw_addr_perm = g_value_dup_string (value);
@@ -14014,6 +14002,9 @@ get_property (GObject *object, guint prop_id,
 	case PROP_PHYSICAL_PORT_ID:
 		g_value_set_string (value, priv->physical_port_id);
 		break;
+	case PROP_IS_MASTER:
+		g_value_set_boolean (value, priv->is_master);
+		break;
 	case PROP_MASTER:
 		g_value_set_object (value, nm_device_get_master (self));
 		break;
@@ -14276,6 +14267,11 @@ nm_device_class_init (NMDeviceClass *klass)
 	                         NULL,
 	                         G_PARAM_READABLE |
 	                         G_PARAM_STATIC_STRINGS);
+	obj_properties[PROP_IS_MASTER] =
+	    g_param_spec_boolean (NM_DEVICE_IS_MASTER, "", "",
+	                          FALSE,
+	                          G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |
+	                          G_PARAM_STATIC_STRINGS);
 	obj_properties[PROP_MASTER] =
 	    g_param_spec_object (NM_DEVICE_MASTER, "", "",
 	                         NM_TYPE_DEVICE,
diff --git a/src/devices/nm-device.h b/src/devices/nm-device.h
index b5c933c..e7d7994 100644
--- a/src/devices/nm-device.h
+++ b/src/devices/nm-device.h
@@ -120,6 +120,7 @@ nm_device_state_reason_check (NMDeviceStateReason reason)
 #define NM_DEVICE_TYPE_DESC        "type-desc"      /* Internal only */
 #define NM_DEVICE_RFKILL_TYPE      "rfkill-type"    /* Internal only */
 #define NM_DEVICE_IFINDEX          "ifindex"        /* Internal only */
+#define NM_DEVICE_IS_MASTER        "is-master"      /* Internal only */
 #define NM_DEVICE_MASTER           "master"         /* Internal only */
 #define NM_DEVICE_HAS_PENDING_ACTION "has-pending-action" /* Internal only */
 
@@ -195,10 +196,6 @@ typedef struct {
 	const char *connection_type;
 	const NMLinkType *link_types;
 
-	/* Whether the device type is a master-type. This depends purely on the
-	 * type (NMDeviceClass), not the actual device instance. */
-	bool is_master:1;
-
 	void (*state_changed) (NMDevice *device,
 	                       NMDeviceState new_state,
 	                       NMDeviceState old_state,
@@ -510,7 +507,6 @@ gboolean nm_device_check_slave_connection_compatible (NMDevice *device, NMConnec
 gboolean nm_device_unmanage_on_quit (NMDevice *self);
 
 gboolean nm_device_spec_match_list (NMDevice *device, const GSList *specs);
-int      nm_device_spec_match_list_full (NMDevice *self, const GSList *specs, int no_match_value);
 
 gboolean nm_device_is_activating (NMDevice *dev);
 gboolean nm_device_autoconnect_allowed (NMDevice *self);
diff --git a/src/devices/team/nm-device-team.c b/src/devices/team/nm-device-team.c
index 2986664..c457e91 100644
--- a/src/devices/team/nm-device-team.c
+++ b/src/devices/team/nm-device-team.c
@@ -822,7 +822,6 @@ get_property (GObject *object, guint prop_id,
 static void
 nm_device_team_init (NMDeviceTeam * self)
 {
-	nm_assert (nm_device_is_master (NM_DEVICE (self)));
 }
 
 static void
@@ -855,6 +854,7 @@ nm_device_team_new (const char *iface)
 	                                  NM_DEVICE_TYPE_DESC, "Team",
 	                                  NM_DEVICE_DEVICE_TYPE, NM_DEVICE_TYPE_TEAM,
 	                                  NM_DEVICE_LINK_TYPE, NM_LINK_TYPE_TEAM,
+	                                  NM_DEVICE_IS_MASTER, TRUE,
 	                                  NULL);
 }
 
@@ -887,7 +887,6 @@ nm_device_team_class_init (NMDeviceTeamClass *klass)
 	object_class->dispose = dispose;
 	object_class->get_property = get_property;
 
-	parent_class->is_master = TRUE;
 	parent_class->create_and_realize = create_and_realize;
 	parent_class->get_generic_capabilities = get_generic_capabilities;
 	parent_class->is_available = is_available;
